{"version":3,"file":"index.mjs","sources":["../lib/reshape_strategy.js","../lib/increment_offsets.js","../lib/set_view_offsets.js","../lib/offsets.js","../lib/callback_wrapper.js","../lib/nd_accessors.js","../lib/nd.js","../lib/main.js","../lib/0d.js","../lib/1d.js","../lib/2d.js","../lib/3d.js","../lib/4d.js","../lib/5d.js","../lib/6d.js","../lib/7d.js","../lib/8d.js","../lib/9d.js","../lib/10d.js","../lib/0d_accessors.js","../lib/1d_accessors.js","../lib/2d_accessors.js","../lib/3d_accessors.js","../lib/4d_accessors.js","../lib/5d_accessors.js","../lib/6d_accessors.js","../lib/7d_accessors.js","../lib/8d_accessors.js","../lib/9d_accessors.js","../lib/10d_accessors.js","../lib/2d_blocked.js","../lib/3d_blocked.js","../lib/4d_blocked.js","../lib/5d_blocked.js","../lib/6d_blocked.js","../lib/7d_blocked.js","../lib/8d_blocked.js","../lib/9d_blocked.js","../lib/10d_blocked.js","../lib/2d_blocked_accessors.js","../lib/3d_blocked_accessors.js","../lib/4d_blocked_accessors.js","../lib/5d_blocked_accessors.js","../lib/6d_blocked_accessors.js","../lib/7d_blocked_accessors.js","../lib/8d_blocked_accessors.js","../lib/9d_blocked_accessors.js","../lib/10d_blocked_accessors.js","../lib/initialize_array_views.js","../lib/factory.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport iterationOrder from '@stdlib/ndarray-base-iteration-order';\nimport { assign as minmaxViewBufferIndex } from '@stdlib/ndarray-base-minmax-view-buffer-index';\nimport ndarraylike2object from '@stdlib/ndarray-base-ndarraylike2object';\nimport assign from '@stdlib/ndarray-base-assign';\nimport ndarraylike2ndarray from '@stdlib/ndarray-base-ndarraylike2ndarray';\nimport emptyLike from '@stdlib/ndarray-base-empty-like';\n\n\n// FUNCTIONS //\n\n/**\n* Returns an input ndarray.\n*\n* @private\n* @param {ndarrayLike} x - input ndarray\n* @returns {ndarrayLike} input ndarray\n*/\nfunction identity( x ) {\n\treturn x;\n}\n\n/**\n* Broadcasts a zero-dimensional ndarray to a one-dimensional ndarray view containing a single element.\n*\n* @private\n* @param {ndarrayLike} x - input ndarray\n* @returns {ndarrayLike} broadcasted ndarray view\n*/\nfunction broadcast( x ) {\n\t// NOTE: the following properties must be set in the exact same order as in `x` in order to ensure that the returned object has the same hidden shape as the input ndarray-like object...\n\treturn {\n\t\t'dtype': x.dtype,\n\t\t'data': x.data,\n\t\t'shape': [ 1 ],\n\t\t'strides': [ 0 ],\n\t\t'offset': x.offset,\n\t\t'order': x.order\n\t};\n}\n\n/**\n* Returns a function which returns an ndarray view in which the singleton dimensions are removed from an input ndarray having only a single non-singleton dimension.\n*\n* @private\n* @param {ndarrayLike} arr - original ndarray\n* @param {NonNegativeInteger} index - index of the non-singleton dimension\n* @returns {Function} function for returning an ndarray view\n*/\nfunction squeeze( arr, index ) {\n\tvar sh = [ arr.shape[ index ] ];\n\tvar sx = [ arr.strides[ index ] ];\n\treturn reshape;\n\n\t/**\n\t* Returns an ndarray view in which the singleton dimensions are removed from an input ndarray having only a single non-singleton dimension.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} a squeezed ndarray view\n\t*/\n\tfunction reshape( x ) {\n\t\t// NOTE: the following properties must be set in the exact same order as in `arr` in order to ensure that the returned object has the same hidden shape as the input ndarray-like object...\n\t\treturn {\n\t\t\t'dtype': x.dtype,\n\t\t\t'data': x.data,\n\t\t\t'shape': sh,\n\t\t\t'strides': sx,\n\t\t\t'offset': x.offset,\n\t\t\t'order': x.order\n\t\t};\n\t}\n}\n\n/**\n* Returns a function which returns a one-dimensional ndarray view of a contiguous input ndarray having more than one dimension.\n*\n* @private\n* @param {NonNegativeInteger} len - number of elements in an ndarray\n* @param {integer} iox - iteration order\n* @returns {Function} function for returning a one-dimensional ndarray view\n*/\nfunction contiguous( len, iox ) {\n\tvar xmmv;\n\tvar ind;\n\tvar sh;\n\tvar sx;\n\n\t// Resolve the index of the min/max view buffer element which is the first indexed element...\n\tif ( iox === 1 ) {\n\t\tind = 0;\n\t} else {\n\t\tind = 1;\n\t}\n\t// Initialize an array for storing the min/max view buffer elements:\n\txmmv = [ 0, 0 ]; // [ min, max ]\n\n\t// Initialize the output one-dimensional view's shape and strides:\n\tsh = [ len ];\n\tsx = [ iox ];\n\n\treturn reshape;\n\n\t/**\n\t* Returns a one-dimensional ndarray view of a contiguous input ndarray having more than one dimension.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} a one-dimensional ndarray view\n\t*/\n\tfunction reshape( x ) {\n\t\t// Resolve the minimum and maximum linear indices in the underlying data buffer which are accessible to the input ndarray view:\n\t\tminmaxViewBufferIndex( x.shape, x.strides, x.offset, xmmv );\n\n\t\t// NOTE: the following properties must be set in the exact same order as in `x` in order to ensure that the returned object has the same hidden shape as the input ndarray-like object...\n\t\treturn {\n\t\t\t'dtype': x.dtype,\n\t\t\t'data': x.data,\n\t\t\t'shape': sh,\n\t\t\t'strides': sx,\n\t\t\t'offset': xmmv[ ind ], // the index of the first indexed element\n\t\t\t'order': x.order\n\t\t};\n\t}\n}\n\n/**\n* Returns a function which copies an input ndarray to a contiguous ndarray workspace.\n*\n* @private\n* @param {NonNegativeInteger} len - number of elements in an ndarray\n* @param {ndarrayLike} workspace - ndarray workspace\n* @returns {Function} function which copies an input ndarray to a contiguous ndarray workspace\n*/\nfunction copy( len, workspace ) {\n\t// NOTE: the following properties must be set in the exact same order as in the input ndarray-like object in order to ensure that the returned object has the same hidden shape...\n\tvar view = {\n\t\t'dtype': workspace.dtype,\n\t\t'data': workspace.data,\n\t\t'shape': [ len ],\n\t\t'strides': [ 1 ],\n\t\t'offset': workspace.offset,\n\t\t'order': workspace.order\n\t};\n\treturn reshape;\n\n\t/**\n\t* Copies an input ndarray to a contiguous ndarray workspace and returns a one-dimensional workspace view.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} one-dimensional workspace view\n\t*/\n\tfunction reshape( x ) {\n\t\tassign( [ x, workspace ] );\n\t\treturn view;\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Returns a function for reshaping input ndarrays which have the same data type, shape, and strides as a provided ndarray.\n*\n* @private\n* @param {ndarrayLike} x - input ndarray\n* @param {string} x.dtype - input ndarray data type\n* @param {Collection} x.data - input ndarray data buffer\n* @param {NonNegativeIntegerArray} x.shape - input ndarray shape\n* @param {IntegerArray} x.strides - input ndarray strides\n* @param {NonNegativeInteger} x.offset - input ndarray index offset\n* @param {string} x.order - input ndarray memory layout\n* @returns {Function} function implementing a reshape strategy\n*/\nfunction strategy( x ) {\n\tvar ndims;\n\tvar xmmv;\n\tvar len;\n\tvar iox;\n\tvar sh;\n\tvar ns;\n\tvar i;\n\n\t// Resolve the number of array dimensions:\n\tsh = x.shape;\n\tndims = sh.length;\n\n\t// Check whether the ndarray is zero-dimensional...\n\tif ( ndims === 0 ) {\n\t\treturn broadcast;\n\t}\n\t// Check whether the ndarray is already one-dimensional...\n\tif ( ndims === 1 ) {\n\t\treturn identity;\n\t}\n\t// Determine the number of singleton dimensions...\n\tlen = 1; // number of elements\n\tns = 0;  // number of singleton dimensions\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\t// Check whether the current dimension is a singleton dimension...\n\t\tif ( sh[ i ] === 1 ) {\n\t\t\tns += 1;\n\t\t}\n\t\tlen *= sh[ i ];\n\t}\n\t// Determine whether the ndarray has only **one** non-singleton dimension (e.g., ndims=4, shape=[10,1,1,1]) so that we can simply create an ndarray view without the singleton dimensions...\n\tif ( ns === ndims-1 ) {\n\t\t// Get the index of the non-singleton dimension...\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tif ( sh[ i ] !== 1 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn squeeze( x, i );\n\t}\n\tiox = iterationOrder( x.strides ); // +/-1\n\n\t// Determine whether we can avoid copying data...\n\tif ( iox !== 0 ) {\n\t\t// Determine the minimum and maximum linear indices which are accessible by the ndarray view:\n\t\txmmv = minmaxViewBufferIndex( sh, x.strides, x.offset, [ 0, 0 ] );\n\n\t\t// Determine whether we can ignore shape (and strides) and create a new one-dimensional ndarray view...\n\t\tif ( len === ( xmmv[1]-xmmv[0]+1 ) ) {\n\t\t\treturn contiguous( len, iox );\n\t\t}\n\t\t// The ndarray is non-contiguous, so we cannot directly interpret as a one-dimensional ndarray...\n\n\t\t// Fall-through to copying to a workspace ndarray...\n\t}\n\t// At this point, we're dealing with a non-contiguous multi-dimensional ndarray, so we need to copy to a contiguous workspace:\n\treturn copy( len, ndarraylike2object( emptyLike( ndarraylike2ndarray( x ) ) ) ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default strategy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Increments index offsets according to a list of increments.\n*\n* ## Notes\n*\n* -   This function mutates the list of index offsets.\n*\n* @private\n* @param {NonNegativeIntegerArray} offsets - list of index offsets\n* @param {NonNegativeIntegerArray} inc - list of increments\n* @returns {NonNegativeIntegerArray} updated offsets\n*/\nfunction incrementOffsets( offsets, inc ) {\n\tvar i;\n\tfor ( i = 0; i < offsets.length; i++ ) {\n\t\toffsets[ i ] += inc[ i ];\n\t}\n\treturn offsets;\n}\n\n\n// EXPORTS //\n\nexport default incrementOffsets;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Sets view offsets according to a list of index offsets.\n*\n* ## Notes\n*\n* -   This function skips the second element in the list of index offsets, as that is assumed to correspond to the output ndarray which does not have a corresponding view. Meaning, the list of views is expected to have `N` elements, and the list of index offsets is expected to have `N+1` elements.\n* -   This function mutates the provides view objects.\n*\n* @private\n* @param {Array<Object>} views - list of ndarray-like objects representing ndarray views\n* @param {NonNegativeIntegerArray} offsets - list of index offsets\n* @returns {Array<Object>} updated views\n*/\nfunction setViewOffsets( views, offsets ) {\n\tvar i;\n\tvar j;\n\tfor ( i = 0, j = 0; i < offsets.length; i++ ) {\n\t\tif ( i === 1 ) { // note: expected to correspond to the output ndarray which does not have a corresponding view\n\t\t\tcontinue;\n\t\t}\n\t\tviews[ j ].offset = offsets[ i ];\n\t\tj += 1;\n\t}\n\treturn views;\n}\n\n\n// EXPORTS //\n\nexport default setViewOffsets;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Resolves index offsets from a list of ndarray-like objects.\n*\n* @private\n* @param {ArrayLikeObject<Object>} arrays - list of ndarray-like objects\n* @returns {NonNegativeIntegerArray} list of offsets\n*/\nfunction offsets( arrays ) {\n\tvar out = [];\n\tvar i;\n\tfor ( i = 0; i < arrays.length; i++ ) {\n\t\tout.push( arrays[ i ].offset );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default offsets;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport put from '@stdlib/array-base-put';\nimport { assign as ind2sub } from '@stdlib/ndarray-base-ind2sub';\nimport zeros from '@stdlib/array-base-zeros';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Wraps a provided callback function.\n*\n* @private\n* @param {ndarray} arr - input ndarray\n* @param {ndarray} view - reduced view of the input ndarray\n* @param {NonNegativeIntegerArray} idx - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - loop dimensions\n* @param {NonNegativeIntegerArray} lidx - current loop iteration indices\n* @param {NonNegativeIntegerArray} cdims - core dimensions\n* @param {Function} clbk - callback function\n* @param {thisArg} thisArg - callback execution context\n* @returns {Function} callback wrapper\n*/\nfunction wrap( arr, view, idx, ldims, lidx, cdims, clbk, thisArg ) {\n\tvar cidx = zeros( cdims.length ); // workspace for storing core iteration indices\n\tput( idx, ldims, lidx, MODE );\n\treturn wrapper;\n\n\t/**\n\t* Invokes a callback function.\n\t*\n\t* @private\n\t* @param {*} v - value\n\t* @param {NonNegativeInteger} aidx - current array element index\n\t* @returns {*} result\n\t*/\n\tfunction wrapper( v, aidx ) {\n\t\tind2sub( view.shape, view.strides, view.offset, view.order, aidx, MODE, cidx ); // eslint-disable-line max-len\n\t\tput( idx, cdims, cidx, MODE );\n\t\treturn clbk.call( thisArg, v, idx.slice(), arr );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default wrap;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport ind2sub from '@stdlib/ndarray-base-ind2sub';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1 ];\n* var cdims = [ 2, 3 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 4 ];\n*\n* // Perform a reduction:\n* unarynd( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 6.0, 14.0, 22.0 ] ]\n*/\nfunction unarynd( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar len;\n\tvar arr;\n\tvar sub;\n\tvar set;\n\tvar sh;\n\tvar iv;\n\tvar io;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar j;\n\tvar f;\n\n\tN = arrays.length;\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate based on the linear **view** index, regardless as to how the data is stored in memory...\n\tio = zeros( N );\n\tfor ( i = 0; i < len; i++ ) {\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tarr = arrays[ j ];\n\t\t\tio[ j ] = vind2bind( sh, arr.strides, iv[ j ], arr.order, i, MODE );\n\t\t}\n\t\tsetViewOffsets( views, io );\n\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\tsub = ind2sub( sh, strides, 0, x.order, i, MODE );\n\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, sub, cdims, clbk, thisArg );\n\t\tset( ybuf, io[1], ( hasOpts ) ? fcn( views, opts, f ) : fcn( views, f ) );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unarynd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport ind2sub from '@stdlib/ndarray-base-ind2sub';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1 ];\n* var cdims = [ 2, 3 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 4 ];\n*\n* // Perform a reduction:\n* unarynd( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 8.0, 16.0, 24.0 ] ]\n*/\nfunction unarynd( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar len;\n\tvar arr;\n\tvar sub;\n\tvar sh;\n\tvar iv;\n\tvar io;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar j;\n\tvar f;\n\n\tN = arrays.length;\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate based on the linear **view** index, regardless as to how the data is stored in memory...\n\tio = zeros( N );\n\tfor ( i = 0; i < len; i++ ) {\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tarr = arrays[ j ];\n\t\t\tio[ j ] = vind2bind( sh, arr.strides, iv[ j ], arr.order, i, MODE );\n\t\t}\n\t\tsetViewOffsets( views, io );\n\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\tsub = ind2sub( sh, strides, 0, x.order, i, MODE );\n\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, sub, cdims, clbk, thisArg );\n\t\tybuf[ io[1] ] = ( hasOpts ) ? fcn( v, f, opts ) : fcn( v, f );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unarynd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport isFunction from '@stdlib/assert-is-function';\nimport ndarray2object from '@stdlib/ndarray-base-ndarraylike2object';\nimport normalizeIndices from '@stdlib/ndarray-base-to-unique-normalized-indices';\nimport indicesComplement from '@stdlib/array-base-indices-complement';\nimport takeIndexed2 from '@stdlib/array-base-take-indexed2';\nimport zeros from '@stdlib/array-base-zeros';\nimport iterationOrder from '@stdlib/ndarray-base-iteration-order';\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport numel from '@stdlib/ndarray-base-numel';\nimport join from '@stdlib/array-base-join';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport initializeViews from './initialize_array_views.js';\nimport reshapeStrategy from './reshape_strategy.js';\nimport blockedaccessorunary2d from './2d_blocked_accessors.js';\nimport blockedaccessorunary3d from './3d_blocked_accessors.js';\nimport blockedaccessorunary4d from './4d_blocked_accessors.js';\nimport blockedaccessorunary5d from './5d_blocked_accessors.js';\nimport blockedaccessorunary6d from './6d_blocked_accessors.js';\nimport blockedaccessorunary7d from './7d_blocked_accessors.js';\nimport blockedaccessorunary8d from './8d_blocked_accessors.js';\nimport blockedaccessorunary9d from './9d_blocked_accessors.js';\nimport blockedaccessorunary10d from './10d_blocked_accessors.js';\nimport blockedunary2d from './2d_blocked.js';\nimport blockedunary3d from './3d_blocked.js';\nimport blockedunary4d from './4d_blocked.js';\nimport blockedunary5d from './5d_blocked.js';\nimport blockedunary6d from './6d_blocked.js';\nimport blockedunary7d from './7d_blocked.js';\nimport blockedunary8d from './8d_blocked.js';\nimport blockedunary9d from './9d_blocked.js';\nimport blockedunary10d from './10d_blocked.js';\nimport accessorunary0d from './0d_accessors.js';\nimport accessorunary1d from './1d_accessors.js';\nimport accessorunary2d from './2d_accessors.js';\nimport accessorunary3d from './3d_accessors.js';\nimport accessorunary4d from './4d_accessors.js';\nimport accessorunary5d from './5d_accessors.js';\nimport accessorunary6d from './6d_accessors.js';\nimport accessorunary7d from './7d_accessors.js';\nimport accessorunary8d from './8d_accessors.js';\nimport accessorunary9d from './9d_accessors.js';\nimport accessorunary10d from './10d_accessors.js';\nimport accessorunarynd from './nd_accessors.js';\nimport unary0d from './0d.js';\nimport unary1d from './1d.js';\nimport unary2d from './2d.js';\nimport unary3d from './3d.js';\nimport unary4d from './4d.js';\nimport unary5d from './5d.js';\nimport unary6d from './6d.js';\nimport unary7d from './7d.js';\nimport unary8d from './8d.js';\nimport unary9d from './9d.js';\nimport unary10d from './10d.js';\nimport unarynd from './nd.js';\n\n\n// VARIABLES //\n\nvar UNARY = [\n\tunary0d,\n\tunary1d,\n\tunary2d,\n\tunary3d,\n\tunary4d,\n\tunary5d,\n\tunary6d,\n\tunary7d,\n\tunary8d,\n\tunary9d,\n\tunary10d\n];\nvar ACCESSOR_UNARY = [\n\taccessorunary0d,\n\taccessorunary1d,\n\taccessorunary2d,\n\taccessorunary3d,\n\taccessorunary4d,\n\taccessorunary5d,\n\taccessorunary6d,\n\taccessorunary7d,\n\taccessorunary8d,\n\taccessorunary9d,\n\taccessorunary10d\n];\nvar BLOCKED_UNARY = [\n\tblockedunary2d, // 0\n\tblockedunary3d,\n\tblockedunary4d,\n\tblockedunary5d,\n\tblockedunary6d,\n\tblockedunary7d,\n\tblockedunary8d,\n\tblockedunary9d,\n\tblockedunary10d // 8\n];\nvar BLOCKED_ACCESSOR_UNARY = [\n\tblockedaccessorunary2d, // 0\n\tblockedaccessorunary3d,\n\tblockedaccessorunary4d,\n\tblockedaccessorunary5d,\n\tblockedaccessorunary6d,\n\tblockedaccessorunary7d,\n\tblockedaccessorunary8d,\n\tblockedaccessorunary9d,\n\tblockedaccessorunary10d // 8\n];\nvar MAX_DIMS = UNARY.length - 1;\n\n\n// MAIN //\n\n/**\n* Performs a reduction over a list of specified dimensions in an input ndarray via a one-dimensional strided array reduction function accepting a callback and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n* @param {IntegerArray} dims - list of dimensions over which to perform a reduction\n* @param {Options} [options] - function options\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n* @throws {Error} arrays must have the expected number of dimensions\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide unique dimension indices\n* @throws {Error} arrays must have the same loop dimension sizes\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*    return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Perform a reduction:\n* unaryReduceStrided1dBy( maxBy, [ x, y ], [ 2, 3 ], clbk );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 8.0, 16.0, 24.0 ] ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*    return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 0 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Perform a reduction:\n* unaryReduceStrided1dBy( maxBy, [ x, y ], [ 0, 1, 2, 3 ], clbk );\n*\n* var v = y.data;\n* // returns <Float64Array>[ 24.0 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*    return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Perform a reduction:\n* unaryReduceStrided1dBy( maxBy, [ x, y ], [], clbk );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 2.0, 4.0 ], [ 6.0, 8.0 ] ], [ [ 10.0, 12.0 ], [ 14.0, 16.0 ] ], [ [ 18.0, 20.0 ], [ 22.0, 24.0 ] ] ]\n*/\nfunction unaryReduceStrided1dBy( fcn, arrays, dims, options, clbk, thisArg ) { // eslint-disable-line max-statements\n\tvar workspace;\n\tvar strategy;\n\tvar views;\n\tvar ndims;\n\tvar ldims;\n\tvar nargs;\n\tvar opts;\n\tvar arr;\n\tvar tmp;\n\tvar len;\n\tvar shx;\n\tvar shc;\n\tvar shl;\n\tvar iox;\n\tvar ioy;\n\tvar ord;\n\tvar FLG;\n\tvar ctx;\n\tvar sc;\n\tvar sl;\n\tvar sy;\n\tvar cb;\n\tvar d;\n\tvar s;\n\tvar N;\n\tvar M;\n\tvar K;\n\tvar x;\n\tvar y;\n\tvar i;\n\tvar j;\n\n\tnargs = arguments.length;\n\tFLG = false;\n\n\t// Case: ( fcn, arrays, dims, clbk )\n\tif ( nargs < 5 ) {\n\t\topts = {};\n\t\tcb = options;\n\t}\n\t// Case: ( fcn, arrays, dims, options, clbk, thisArg )\n\telse if ( nargs > 5 ) {\n\t\tFLG = true;\n\t\topts = options;\n\t\tcb = clbk;\n\t\tctx = thisArg;\n\t}\n\t// Case: ( fcn, arrays, dims, clbk, thisArg )\n\telse if ( isFunction( options ) ) {\n\t\topts = {};\n\t\tcb = options;\n\t\tctx = clbk;\n\t}\n\t// Case: ( fcn, arrays, dims, options, clbk )\n\telse {\n\t\tFLG = true;\n\t\topts = options;\n\t\tcb = clbk;\n\t}\n\t// Standardize ndarray meta data...\n\tN = arrays.length;\n\tarr = [];\n\tfor ( i = 0; i < N; i++ ) {\n\t\tarr.push( ndarray2object( arrays[ i ] ) );\n\t}\n\t// Cache references to the input and output arrays:\n\tx = arr[ 0 ];\n\ty = arr[ 1 ];\n\n\t// Resolve the number of input array dimensions:\n\tshx = x.shape;\n\tndims = shx.length;\n\n\t// Verify that we've been provided a list of unique dimension indices...\n\tM = dims.length;\n\td = normalizeIndices( dims, ndims-1 );\n\tif ( d === null ) {\n\t\tthrow new RangeError( format( 'invalid argument. Third argument contains an out-of-bounds dimension index. Value: [%s].', join( dims, ',' ) ) );\n\t}\n\td.sort();\n\tif ( d.length !== M ) {\n\t\tthrow new Error( format( 'invalid argument. Third argument must contain a list of unique dimension indices. Value: [%s].', join( dims, ',' ) ) );\n\t}\n\t// Check whether we've been provided a valid number of dimensions to reduce...\n\tif ( M > ndims ) {\n\t\tthrow new RangeError( format( 'invalid argument. Number of specified dimensions cannot exceed the number of dimensions in the input array. Number of dimensions: %d. Value: [%s].', ndims, join( dims, ',' ) ) );\n\t}\n\t// Verify that provided ndarrays have the expected number of dimensions...\n\tK = ndims - M;\n\tfor ( i = 1; i < N; i++ ) {\n\t\tif ( arr[ i ].shape.length !== K ) {\n\t\t\tthrow new Error( format( 'invalid argument. Arrays which are not being reduced must have the same number of non-reduced dimensions. Input array shape: [%s]. Number of non-reduced dimensions: %d. Array shape: [%s] (index: %d).', join( shx, ',' ), K, join( arr[ i ].shape, ',' ), i ) );\n\t\t}\n\t}\n\t// Initialize a workspace for storing iteration indices:\n\tworkspace = zeros( ndims );\n\n\t// Resolve the non-reduced (\"loop\") dimensions and associated strides:\n\tldims = indicesComplement( shx.length, d );\n\ttmp = takeIndexed2( shx, x.strides, ldims );\n\tshl = tmp[ 0 ];\n\tsl = tmp[ 1 ];\n\n\t// Resolve the reduced (\"core\") dimensions and associated strides:\n\ttmp = takeIndexed2( shx, x.strides, d );\n\tshc = tmp[ 0 ];\n\tsc = tmp[ 1 ];\n\n\t// Verify that the provided arrays have the same loop dimensions...\n\tlen = 1; // number of elements\n\tfor ( i = 0; i < K; i++ ) {\n\t\ts = shl[ i ];\n\t\tfor ( j = 1; j < N; j++ ) {\n\t\t\tif ( s !== arr[ j ].shape[ i ] ) {\n\t\t\t\tthrow new Error( format( 'invalid argument. Non-reduced dimensions must be consistent across all provided arrays. Input array shape: [%s]. Non-reduced dimension indices: [%s]. Non-reduced dimensions: [%s]. Array shape: [%s] (index: %d).', join( shx, ',' ), join( ldims, ',' ), join( shl, ',' ), join( arr[ j ].shape, ',' ), j ) );\n\t\t\t}\n\t\t}\n\t\t// Note that, if one of the dimensions is `0`, the length will be `0`...\n\t\tlen *= s;\n\t}\n\t// Check whether we were provided empty ndarrays...\n\tif ( len === 0 || ( shc.length && numel( shc ) === 0 ) ) {\n\t\treturn;\n\t}\n\t// Initialize ndarray-like objects for representing sub-array views...\n\tviews = [\n\t\t{\n\t\t\t'dtype': x.dtype,\n\t\t\t'data': x.data,\n\t\t\t'shape': shc,\n\t\t\t'strides': sc,\n\t\t\t'offset': x.offset,\n\t\t\t'order': x.order\n\t\t}\n\t];\n\tinitializeViews( arr, views );\n\n\t// Determine the strategy for reshaping sub-array views of the input array prior to performing a reduction:\n\tstrategy = reshapeStrategy( views[ 0 ] );\n\n\t// Determine whether we can avoid iteration altogether...\n\tif ( K === 0 ) {\n\t\tif ( y.accessorProtocol ) {\n\t\t\treturn ACCESSOR_UNARY[ K ]( fcn, arr, strategy, workspace, ldims, d, opts, FLG, cb, ctx );\n\t\t}\n\t\treturn UNARY[ K ]( fcn, arr, strategy, workspace, ldims, d, opts, FLG, cb, ctx );\n\t}\n\t// Determine whether we only have one loop dimension and can thus readily perform one-dimensional iteration...\n\tif ( K === 1 ) {\n\t\tif ( y.accessorProtocol ) {\n\t\t\treturn ACCESSOR_UNARY[ K ]( fcn, arr, strategy, workspace, views, ldims, d, sl, opts, FLG, cb, ctx );\n\t\t}\n\t\treturn UNARY[ K ]( fcn, arr, strategy, views, workspace, ldims, d, sl, opts, FLG, cb, ctx );\n\t}\n\tsy = y.strides;\n\tiox = iterationOrder( sl ); // +/-1\n\tioy = iterationOrder( sy ); // +/-1\n\n\t// Determine whether we can avoid blocked iteration...\n\tord = strides2order( sl );\n\tif ( iox !== 0 && ioy !== 0 && ord === strides2order( sy ) && K <= MAX_DIMS ) {\n\t\t// So long as iteration for each respective array always moves in the same direction (i.e., no mixed sign strides) and the memory layouts are the same, we can leverage cache-optimal (i.e., normal) nested loops without resorting to blocked iteration...\n\t\tif ( y.accessorProtocol ) {\n\t\t\treturn ACCESSOR_UNARY[ K ]( fcn, arr, strategy, views, workspace, ldims, d, sl, ord === 1, opts, FLG, cb, ctx );\n\t\t}\n\t\treturn UNARY[ K ]( fcn, arr, strategy, views, workspace, ldims, d, sl, ord === 1, opts, FLG, cb, ctx );\n\t}\n\t// At this point, we're either dealing with non-contiguous n-dimensional arrays, high dimensional n-dimensional arrays, and/or arrays having differing memory layouts, so our only hope is that we can still perform blocked iteration...\n\n\t// Determine whether we can perform blocked iteration...\n\tif ( K <= MAX_DIMS ) {\n\t\tif ( y.accessorProtocol ) {\n\t\t\treturn BLOCKED_ACCESSOR_UNARY[ K-2 ]( fcn, arr, strategy, views, workspace, ldims, d, sl, opts, FLG, cb, ctx );\n\t\t}\n\t\treturn BLOCKED_UNARY[ K-2 ]( fcn, arr, strategy, views, workspace, ldims, d, sl, opts, FLG, cb, ctx );\n\t}\n\t// Fall-through to linear view iteration without regard for how data is stored in memory (i.e., take the slow path)...\n\tif ( y.accessorProtocol ) {\n\t\treturn accessorunarynd( fcn, arr, strategy, views, workspace, ldims, d, sl, opts, FLG, cb, ctx );\n\t}\n\tunarynd( fcn, arr, strategy, views, workspace, ldims, d, sl, opts, FLG, cb, ctx );\n}\n\n\n// EXPORTS //\n\nexport default unaryReduceStrided1dBy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport without from '@stdlib/array-base-without';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over a list of specified dimensions in an input ndarray according to a callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {thisArg} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*    return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var ybuf = new Float64Array( [ 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 2, 2 ];\n* var ysh = [];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 0 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [];\n* var cdims = [ 0, 1 ];\n*\n* // Perform a reduction:\n* unary0d( maxBy, [ x, y ], strategy, ibuf, ldims, cdims, {}, false, clbk, {} );\n*\n* var v = y.data;\n* // returns <Float64Array>[ 8.0 ]\n*/\nfunction unary0d( fcn, arrays, strategy, ibuf, ldims, cdims, opts, hasOpts, clbk, thisArg ) {\n\tvar arr;\n\tvar x;\n\tvar y;\n\tvar f;\n\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\tf = wrap( x.ref, x, ibuf, ldims, [], cdims, clbk, thisArg );\n\n\tarr = without( arrays, 1 );\n\tarr[ 0 ] = strategy( x );\n\n\ty.data[ y.offset ] = ( hasOpts ) ? fcn( arr, opts, f ) : fcn( arr, f );\n}\n\n\n// EXPORTS //\n\nexport default unary0d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0 ];\n* var cdims = [ 1, 2 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 4 ];\n*\n* // Perform a reduction:\n* unary1d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ 8.0, 16.0, 24.0 ]\n*/\nfunction unary1d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar sh;\n\tvar S0;\n\tvar iv;\n\tvar i0;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tdv0 = [ strides[0] ];\n\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\tdv0.push( arrays[i].strides[0] );\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tsetViewOffsets( views, iv );\n\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i0 ], cdims, clbk, thisArg );\n\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\tincrementOffsets( iv, dv0 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1 ];\n* var cdims = [ 2, 3 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 4 ];\n*\n* // Perform a reduction:\n* unary2d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 8.0, 16.0, 24.0 ] ]\n*/\nfunction unary2d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdv0 = [ strides[1] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[0] - ( S0*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[1] );\n\t\t\tdv1.push( sv[0] - ( S0*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tsetViewOffsets( views, iv );\n\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i1, i0 ], cdims, clbk, thisArg );\n\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\tincrementOffsets( iv, dv0 );\n\t\t}\n\t\tincrementOffsets( iv, dv1 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2 ];\n* var cdims = [ 3, 4 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary3d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 8.0, 16.0, 24.0 ] ] ]\n*/\nfunction unary3d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdv0 = [ strides[2] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[2] ) ];\n\t\tdv2 = [ strides[0] - ( S1*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[2] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[2] ) );\n\t\t\tdv2.push( sv[0] - ( S1*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv1 );\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3 ];\n* var cdims = [ 4, 5 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary4d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ]\n*/\nfunction unary4d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdv0 = [ strides[3] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[2] - ( S0*strides[3] ) ];\n\t\tdv2 = [ strides[1] - ( S1*strides[2] ) ];\n\t\tdv3 = [ strides[0] - ( S2*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[3] );\n\t\t\tdv1.push( sv[2] - ( S0*sv[3] ) );\n\t\t\tdv2.push( sv[1] - ( S1*sv[2] ) );\n\t\t\tdv3.push( sv[0] - ( S2*sv[1]) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv3 );\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4 ];\n* var cdims = [ 5, 6 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary5d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ]\n*/\nfunction unary5d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdv0 = [ strides[4] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[3] - ( S0*strides[4] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[3] ) ];\n\t\tdv3 = [ strides[1] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[0] - ( S3*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[4] );\n\t\t\tdv1.push( sv[3] - ( S0*sv[4] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[3] ) );\n\t\t\tdv3.push( sv[1] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[0] - ( S3*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv3 );\n\t\t}\n\t\tincrementOffsets( iv, dv4 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5 ];\n* var cdims = [ 6, 7 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary6d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ]\n*/\nfunction unary6d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdv0 = [ strides[5] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[4] - ( S0*strides[5] ) ];\n\t\tdv2 = [ strides[3] - ( S1*strides[4] ) ];\n\t\tdv3 = [ strides[2] - ( S2*strides[3] ) ];\n\t\tdv4 = [ strides[1] - ( S3*strides[2] ) ];\n\t\tdv5 = [ strides[0] - ( S4*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[5] );\n\t\t\tdv1.push( sv[4] - ( S0*sv[5] ) );\n\t\t\tdv2.push( sv[3] - ( S1*sv[4] ) );\n\t\t\tdv3.push( sv[2] - ( S2*sv[3] ) );\n\t\t\tdv4.push( sv[1] - ( S3*sv[2] ) );\n\t\t\tdv5.push( sv[0] - ( S4*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv4 );\n\t\t}\n\t\tincrementOffsets( iv, dv5 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6 ];\n* var cdims = [ 7, 8 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary7d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ]\n*/\nfunction unary7d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdv0 = [ strides[6] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[5] - ( S0*strides[6] ) ];\n\t\tdv2 = [ strides[4] - ( S1*strides[5] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[4] ) ];\n\t\tdv4 = [ strides[2] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[1] - ( S4*strides[2] ) ];\n\t\tdv6 = [ strides[0] - ( S5*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[6] );\n\t\t\tdv1.push( sv[5] - ( S0*sv[6] ) );\n\t\t\tdv2.push( sv[4] - ( S1*sv[5] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[4] ) );\n\t\t\tdv4.push( sv[2] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[1] - ( S4*sv[2] ) );\n\t\t\tdv6.push( sv[0] - ( S5*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[6] - ( S5*strides[5] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i6, i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv5 );\n\t\t}\n\t\tincrementOffsets( iv, dv6 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7 ];\n* var cdims = [ 8, 9 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary8d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ]\n*/\nfunction unary8d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdv0 = [ strides[7] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[6] - ( S0*strides[7] ) ];\n\t\tdv2 = [ strides[5] - ( S1*strides[6] ) ];\n\t\tdv3 = [ strides[4] - ( S2*strides[5] ) ];\n\t\tdv4 = [ strides[3] - ( S3*strides[4] ) ];\n\t\tdv5 = [ strides[2] - ( S4*strides[3] ) ];\n\t\tdv6 = [ strides[1] - ( S5*strides[2] ) ];\n\t\tdv7 = [ strides[0] - ( S6*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[7] );\n\t\t\tdv1.push( sv[6] - ( S0*sv[7] ) );\n\t\t\tdv2.push( sv[5] - ( S1*sv[6] ) );\n\t\t\tdv3.push( sv[4] - ( S2*sv[5] ) );\n\t\t\tdv4.push( sv[3] - ( S3*sv[4] ) );\n\t\t\tdv5.push( sv[2] - ( S4*sv[3] ) );\n\t\t\tdv6.push( sv[1] - ( S5*sv[2] ) );\n\t\t\tdv7.push( sv[0] - ( S6*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[6] - ( S5*strides[5] ) ];\n\t\tdv7 = [ strides[7] - ( S6*strides[6] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i7, i6, i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv6 );\n\t\t}\n\t\tincrementOffsets( iv, dv7 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\n* var cdims = [ 9, 10 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary9d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ] ]\n*/\nfunction unary9d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdv0 = [ strides[8] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[7] - ( S0*strides[8] ) ];\n\t\tdv2 = [ strides[6] - ( S1*strides[7] ) ];\n\t\tdv3 = [ strides[5] - ( S2*strides[6] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[5] ) ];\n\t\tdv5 = [ strides[3] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[2] - ( S5*strides[3] ) ];\n\t\tdv7 = [ strides[1] - ( S6*strides[2] ) ];\n\t\tdv8 = [ strides[0] - ( S7*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[8] );\n\t\t\tdv1.push( sv[7] - ( S0*sv[8] ) );\n\t\t\tdv2.push( sv[6] - ( S1*sv[7] ) );\n\t\t\tdv3.push( sv[5] - ( S2*sv[6] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[5] ) );\n\t\t\tdv5.push( sv[3] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[2] - ( S5*sv[3] ) );\n\t\t\tdv7.push( sv[1] - ( S6*sv[2] ) );\n\t\t\tdv8.push( sv[0] - ( S7*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[6] - ( S5*strides[5] ) ];\n\t\tdv7 = [ strides[7] - ( S6*strides[6] ) ];\n\t\tdv8 = [ strides[8] - ( S7*strides[7] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t\tdv8.push( sv[8] - ( S7*sv[7] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv7 );\n\t\t}\n\t\tincrementOffsets( iv, dv8 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\n* var cdims = [ 10, 11 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary10d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ] ] ]\n*/\nfunction unary10d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar dv9;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdv0 = [ strides[9] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[8] - ( S0*strides[9] ) ];\n\t\tdv2 = [ strides[7] - ( S1*strides[8] ) ];\n\t\tdv3 = [ strides[6] - ( S2*strides[7] ) ];\n\t\tdv4 = [ strides[5] - ( S3*strides[6] ) ];\n\t\tdv5 = [ strides[4] - ( S4*strides[5] ) ];\n\t\tdv6 = [ strides[3] - ( S5*strides[4] ) ];\n\t\tdv7 = [ strides[2] - ( S6*strides[3] ) ];\n\t\tdv8 = [ strides[1] - ( S7*strides[2] ) ];\n\t\tdv9 = [ strides[0] - ( S8*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[9] );\n\t\t\tdv1.push( sv[8] - ( S0*sv[9] ) );\n\t\t\tdv2.push( sv[7] - ( S1*sv[8] ) );\n\t\t\tdv3.push( sv[6] - ( S2*sv[7] ) );\n\t\t\tdv4.push( sv[5] - ( S3*sv[6] ) );\n\t\t\tdv5.push( sv[4] - ( S4*sv[5] ) );\n\t\t\tdv6.push( sv[3] - ( S5*sv[4] ) );\n\t\t\tdv7.push( sv[2] - ( S6*sv[3] ) );\n\t\t\tdv8.push( sv[1] - ( S7*sv[2] ) );\n\t\t\tdv9.push( sv[0] - ( S8*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[6] - ( S5*strides[5] ) ];\n\t\tdv7 = [ strides[7] - ( S6*strides[6] ) ];\n\t\tdv8 = [ strides[8] - ( S7*strides[7] ) ];\n\t\tdv9 = [ strides[9] - ( S8*strides[8] ) ];  // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t\tdv8.push( sv[8] - ( S7*sv[7] ) );\n\t\t\tdv9.push( sv[9] - ( S8*sv[8] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv8 );\n\t\t}\n\t\tincrementOffsets( iv, dv9 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport without from '@stdlib/array-base-without';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over a list of specified dimensions in an input ndarray according to a callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {thisArg} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*    return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 2, 2 ];\n* var ysh = [];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 0 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [];\n* var cdims = [ 0, 1 ];\n*\n* // Perform a reduction:\n* unary0d( maxBy, [ x, y ], strategy, ibuf, ldims, cdims, {}, false, clbk, {} );\n*\n* var v = y.data.get( 0 );\n* // returns 8.0\n*/\nfunction unary0d( fcn, arrays, strategy, ibuf, ldims, cdims, opts, hasOpts, clbk, thisArg ) {\n\tvar arr;\n\tvar x;\n\tvar y;\n\tvar f;\n\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\tf = wrap( x.ref, x, ibuf, ldims, [], cdims, clbk, thisArg );\n\n\tarr = without( arrays, 1 );\n\tarr[ 0 ] = strategy( x );\n\n\tif ( hasOpts ) {\n\t\ty.accessors[ 1 ]( y.data, y.offset, fcn( arr, opts, f ) );\n\t} else {\n\t\ty.accessors[ 1 ]( y.data, y.offset, fcn( arr, f ) );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary0d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import zeros from '@stdlib/array-base-zeros';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0 ];\n* var cdims = [ 1, 2 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 4 ];\n*\n* // Perform a reduction:\n* unary1d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ 8.0, 16.0, 24.0 ]\n*/\nfunction unary1d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar sh;\n\tvar S0;\n\tvar iv;\n\tvar i0;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = sh[ 0 ];\n\tdv0 = [ strides[0] ];\n\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\tdv0.push( arrays[i].strides[0] );\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tsetViewOffsets( views, iv );\n\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i0 ], cdims, clbk, thisArg );\n\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ): fcn( v, f ) );\n\t\tincrementOffsets( iv, dv0 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import zeros from '@stdlib/array-base-zeros';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1 ];\n* var cdims = [ 2, 3 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 4 ];\n*\n* // Perform a reduction:\n* unary2d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 6.0, 14.0, 22.0 ] ]\n*/\nfunction unary2d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar set;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdv0 = [ strides[1] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[0] - ( S0*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[1] );\n\t\t\tdv1.push( sv[0] - ( S0*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tsetViewOffsets( views, iv );\n\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i1, i0 ], cdims, clbk, thisArg );\n\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( views, opts, f ) : fcn( views, f ) );\n\t\t\tincrementOffsets( iv, dv0 );\n\t\t}\n\t\tincrementOffsets( iv, dv1 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2 ];\n* var cdims = [ 3, 4 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary3d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 8.0, 16.0, 24.0 ] ] ]\n*/\nfunction unary3d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdv0 = [ strides[2] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[2] ) ];\n\t\tdv2 = [ strides[0] - ( S1*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[2] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[2] ) );\n\t\t\tdv2.push( sv[0] - ( S1*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv1 );\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3 ];\n* var cdims = [ 4, 5 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary4d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ]\n*/\nfunction unary4d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar set;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdv0 = [ strides[3] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[2] - ( S0*strides[3] ) ];\n\t\tdv2 = [ strides[1] - ( S1*strides[2] ) ];\n\t\tdv3 = [ strides[0] - ( S2*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[3] );\n\t\t\tdv1.push( sv[2] - ( S0*sv[3] ) );\n\t\t\tdv2.push( sv[1] - ( S1*sv[2] ) );\n\t\t\tdv3.push( sv[0] - ( S2*sv[1]) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv3 );\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4 ];\n* var cdims = [ 5, 6 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary5d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ]\n*/\nfunction unary5d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdv0 = [ strides[4] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[3] - ( S0*strides[4] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[3] ) ];\n\t\tdv3 = [ strides[1] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[0] - ( S3*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[4] );\n\t\t\tdv1.push( sv[3] - ( S0*sv[4] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[3] ) );\n\t\t\tdv3.push( sv[1] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[0] - ( S3*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv3 );\n\t\t}\n\t\tincrementOffsets( iv, dv4 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5 ];\n* var cdims = [ 6, 7 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary6d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ]\n*/\nfunction unary6d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdv0 = [ strides[5] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[4] - ( S0*strides[5] ) ];\n\t\tdv2 = [ strides[3] - ( S1*strides[4] ) ];\n\t\tdv3 = [ strides[2] - ( S2*strides[3] ) ];\n\t\tdv4 = [ strides[1] - ( S3*strides[2] ) ];\n\t\tdv5 = [ strides[0] - ( S4*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[5] );\n\t\t\tdv1.push( sv[4] - ( S0*sv[5] ) );\n\t\t\tdv2.push( sv[3] - ( S1*sv[4] ) );\n\t\t\tdv3.push( sv[2] - ( S2*sv[3] ) );\n\t\t\tdv4.push( sv[1] - ( S3*sv[2] ) );\n\t\t\tdv5.push( sv[0] - ( S4*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv4 );\n\t\t}\n\t\tincrementOffsets( iv, dv5 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6 ];\n* var cdims = [ 7, 8 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary7d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ]\n*/\nfunction unary7d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdv0 = [ strides[6] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[5] - ( S0*strides[6] ) ];\n\t\tdv2 = [ strides[4] - ( S1*strides[5] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[4] ) ];\n\t\tdv4 = [ strides[2] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[1] - ( S4*strides[2] ) ];\n\t\tdv6 = [ strides[0] - ( S5*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[6] );\n\t\t\tdv1.push( sv[5] - ( S0*sv[6] ) );\n\t\t\tdv2.push( sv[4] - ( S1*sv[5] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[4] ) );\n\t\t\tdv4.push( sv[2] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[1] - ( S4*sv[2] ) );\n\t\t\tdv6.push( sv[0] - ( S5*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[6] - ( S5*strides[5] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i6, i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv5 );\n\t\t}\n\t\tincrementOffsets( iv, dv6 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7 ];\n* var cdims = [ 8, 9 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary8d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ]\n*/\nfunction unary8d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdv0 = [ strides[7] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[6] - ( S0*strides[7] ) ];\n\t\tdv2 = [ strides[5] - ( S1*strides[6] ) ];\n\t\tdv3 = [ strides[4] - ( S2*strides[5] ) ];\n\t\tdv4 = [ strides[3] - ( S3*strides[4] ) ];\n\t\tdv5 = [ strides[2] - ( S4*strides[3] ) ];\n\t\tdv6 = [ strides[1] - ( S5*strides[2] ) ];\n\t\tdv7 = [ strides[0] - ( S6*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[7] );\n\t\t\tdv1.push( sv[6] - ( S0*sv[7] ) );\n\t\t\tdv2.push( sv[5] - ( S1*sv[6] ) );\n\t\t\tdv3.push( sv[4] - ( S2*sv[5] ) );\n\t\t\tdv4.push( sv[3] - ( S3*sv[4] ) );\n\t\t\tdv5.push( sv[2] - ( S4*sv[3] ) );\n\t\t\tdv6.push( sv[1] - ( S5*sv[2] ) );\n\t\t\tdv7.push( sv[0] - ( S6*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[6] - ( S5*strides[5] ) ];\n\t\tdv7 = [ strides[7] - ( S6*strides[6] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i7, i6, i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv6 );\n\t\t}\n\t\tincrementOffsets( iv, dv7 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\n* var cdims = [ 9, 10 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary9d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ] ]\n*/\nfunction unary9d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdv0 = [ strides[8] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[7] - ( S0*strides[8] ) ];\n\t\tdv2 = [ strides[6] - ( S1*strides[7] ) ];\n\t\tdv3 = [ strides[5] - ( S2*strides[6] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[5] ) ];\n\t\tdv5 = [ strides[3] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[2] - ( S5*strides[3] ) ];\n\t\tdv7 = [ strides[1] - ( S6*strides[2] ) ];\n\t\tdv8 = [ strides[0] - ( S7*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[8] );\n\t\t\tdv1.push( sv[7] - ( S0*sv[8] ) );\n\t\t\tdv2.push( sv[6] - ( S1*sv[7] ) );\n\t\t\tdv3.push( sv[5] - ( S2*sv[6] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[5] ) );\n\t\t\tdv5.push( sv[3] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[2] - ( S5*sv[3] ) );\n\t\t\tdv7.push( sv[1] - ( S6*sv[2] ) );\n\t\t\tdv8.push( sv[0] - ( S7*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[6] - ( S5*strides[5] ) ];\n\t\tdv7 = [ strides[7] - ( S6*strides[6] ) ];\n\t\tdv8 = [ strides[8] - ( S7*strides[7] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t\tdv8.push( sv[8] - ( S7*sv[7] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv7 );\n\t\t}\n\t\tincrementOffsets( iv, dv8 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to callback function and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {boolean} isRowMajor - boolean indicating whether the input ndarray is row-major\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\n* var cdims = [ 10, 11 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* unary10d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, true, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ] ] ]\n*/\nfunction unary10d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, isRowMajor, opts, hasOpts, clbk, thisArg ) {\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar dv9;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar i;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Cache a reference to the input ndarray:\n\tx = arrays[ 0 ];\n\n\t// Resolve the output ndarray and associated shape:\n\ty = arrays[ 1 ];\n\tsh = y.shape;\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdv0 = [ strides[9] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[8] - ( S0*strides[9] ) ];\n\t\tdv2 = [ strides[7] - ( S1*strides[8] ) ];\n\t\tdv3 = [ strides[6] - ( S2*strides[7] ) ];\n\t\tdv4 = [ strides[5] - ( S3*strides[6] ) ];\n\t\tdv5 = [ strides[4] - ( S4*strides[5] ) ];\n\t\tdv6 = [ strides[3] - ( S5*strides[4] ) ];\n\t\tdv7 = [ strides[2] - ( S6*strides[3] ) ];\n\t\tdv8 = [ strides[1] - ( S7*strides[2] ) ];\n\t\tdv9 = [ strides[0] - ( S8*strides[1] ) ]; // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[9] );\n\t\t\tdv1.push( sv[8] - ( S0*sv[9] ) );\n\t\t\tdv2.push( sv[7] - ( S1*sv[8] ) );\n\t\t\tdv3.push( sv[6] - ( S2*sv[7] ) );\n\t\t\tdv4.push( sv[5] - ( S3*sv[6] ) );\n\t\t\tdv5.push( sv[4] - ( S4*sv[5] ) );\n\t\t\tdv6.push( sv[3] - ( S5*sv[4] ) );\n\t\t\tdv7.push( sv[2] - ( S6*sv[3] ) );\n\t\t\tdv8.push( sv[1] - ( S7*sv[2] ) );\n\t\t\tdv9.push( sv[0] - ( S8*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdv0 = [ strides[0] ];                     // offset increment for innermost loop\n\t\tdv1 = [ strides[1] - ( S0*strides[0] ) ];\n\t\tdv2 = [ strides[2] - ( S1*strides[1] ) ];\n\t\tdv3 = [ strides[3] - ( S2*strides[2] ) ];\n\t\tdv4 = [ strides[4] - ( S3*strides[3] ) ];\n\t\tdv5 = [ strides[5] - ( S4*strides[4] ) ];\n\t\tdv6 = [ strides[6] - ( S5*strides[5] ) ];\n\t\tdv7 = [ strides[7] - ( S6*strides[6] ) ];\n\t\tdv8 = [ strides[8] - ( S7*strides[7] ) ];\n\t\tdv9 = [ strides[9] - ( S8*strides[8] ) ];  // offset increment for outermost loop\n\t\tfor ( i = 1; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t\tdv8.push( sv[8] - ( S7*sv[7] ) );\n\t\t\tdv9.push( sv[9] - ( S8*sv[8] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the non-reduced ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv8 );\n\t\t}\n\t\tincrementOffsets( iv, dv9 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1 ];\n* var cdims = [ 2, 3 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary2d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 8.0, 16.0, 24.0 ] ]\n*/\nfunction blockedunary2d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar ov1;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tdv1 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov1[ k ] = ov[k] + ( j1*sv[k][1] );\n\t\t}\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t}\n\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2 ];\n* var cdims = [ 3, 4 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary3d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 8.0, 16.0, 24.0 ] ] ]\n*/\nfunction blockedunary3d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar ov1;\n\tvar ov2;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov2[ k ] = ov[k] + ( j2*sv[k][2] );\n\t\t}\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t}\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t}\n\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3 ];\n* var cdims = [ 4, 5 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary4d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ]\n*/\nfunction blockedunary4d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov3[ k ] = ov[k] + ( j3*sv[k][3] );\n\t\t}\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t}\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t}\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t}\n\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4 ];\n* var cdims = [ 5, 6 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary5d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ]\n*/\nfunction blockedunary5d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov4[ k ] = ov[k] + ( j4*sv[k][4] );\n\t\t}\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t}\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t}\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5 ];\n* var cdims = [ 6, 7 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary6d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ]\n*/\nfunction blockedunary6d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov5[ k ] = ov[k] + ( j5*sv[k][5] );\n\t\t}\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t}\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t}\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6 ];\n* var cdims = [ 7, 8 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary7d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ]\n*/\nfunction blockedunary7d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov6[ k ] = ov[k] + ( j6*sv[k][6] );\n\t\t}\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv6[ k ] = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t}\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t}\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements, max-lines-per-function */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7 ];\n* var cdims = [ 8, 9 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary8d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary8d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov7[ k ] = ov[k] + ( j7*sv[k][7] );\n\t\t}\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv7[ k ] = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t}\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv6[ k ] = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t}\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements, max-lines-per-function */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\n* var cdims = [ 9, 10 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary9d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary9d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar ov8;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tov8 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tdv8 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov8[ k ] = ov[k] + ( j8*sv[k][8] );\n\t\t}\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv8[ k ] = sv[k][8] - ( s7*sv[k][7] );\n\t\t\t\tov7[ k ] = ov8[k] + ( j7*sv[k][7] );\n\t\t\t}\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv7[ k ] = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t\t}\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv6[ k ] = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j8+i8, j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv8 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements, max-lines-per-function */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\n* var cdims = [ 10, 11 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary10d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary10d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar dv9;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar ov8;\n\tvar ov9;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tov8 = zeros( N );\n\tov9 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tdv8 = zeros( N );\n\tdv9 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov9[ k ] = ov[k] + ( j9*sv[k][9] );\n\t\t}\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv9[ k ] = sv[k][9] - ( s8*sv[k][8] );\n\t\t\t\tov8[ k ] = ov9[k] + ( j8*sv[k][8] );\n\t\t\t}\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv8[ k ] = sv[k][8] - ( s7*sv[k][7] );\n\t\t\t\t\tov7[ k ] = ov8[k] + ( j7*sv[k][7] );\n\t\t\t\t}\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv7[ k ] = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv6[ k ] = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j9+i9, j8+i8, j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iv[1] ] = ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv8 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv9 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import zeros from '@stdlib/array-base-zeros';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1 ];\n* var cdims = [ 2, 3 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary2d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 6.0, 14.0, 22.0 ] ]\n*/\nfunction blockedunary2d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar ov1;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[1];\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tdv1 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov1[ k ] = ov[k] + ( j1*sv[k][1] );\n\t\t}\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t}\n\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( views, opts, f ) : fcn( views, f ) );\n\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n* var ybuf = toAccessorArray( new Float64Array( [ 0.0, 0.0, 0.0 ] ) );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2 ];\n* var cdims = [ 3, 4 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary3d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 8.0, 16.0, 24.0 ] ] ]\n*/\nfunction blockedunary3d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar ov1;\n\tvar ov2;\n\tvar set;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov2[ k ] = ov[k] + ( j2*sv[k][2] );\n\t\t}\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t}\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t}\n\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3 ];\n* var cdims = [ 4, 5 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary4d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ]\n*/\nfunction blockedunary4d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov3[ k ] = ov[k] + ( j3*sv[k][3] );\n\t\t}\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t}\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t}\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t}\n\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4 ];\n* var cdims = [ 5, 6 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary5d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ]\n*/\nfunction blockedunary5d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[1];\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov4[ k ] = ov[k] + ( j4*sv[k][4] );\n\t\t}\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t}\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t}\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5 ];\n* var cdims = [ 6, 7 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary6d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ]\n*/\nfunction blockedunary6d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[1];\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov5[ k ] = ov[k] + ( j5*sv[k][5] );\n\t\t}\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t}\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t}\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6 ];\n* var cdims = [ 7, 8 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary7d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ]\n*/\nfunction blockedunary7d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov6[ k ] = ov[k] + ( j6*sv[k][6] );\n\t\t}\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv6[ k ] = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t}\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t}\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements, max-lines-per-function */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7 ];\n* var cdims = [ 8, 9 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary8d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary8d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov7[ k ] = ov[k] + ( j7*sv[k][7] );\n\t\t}\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv7[ k ] = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t}\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv6[ k ] = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t}\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements, max-lines-per-function */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\n* var cdims = [ 9, 10 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary9d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary9d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar ov8;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tov8 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tdv8 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov8[ k ] = ov[k] + ( j8*sv[k][8] );\n\t\t}\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv8[ k ] = sv[k][8] - ( s7*sv[k][7] );\n\t\t\t\tov7[ k ] = ov8[k] + ( j7*sv[k][7] );\n\t\t\t}\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv7[ k ] = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t\t}\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv6[ k ] = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j8+i8, j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv8 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len, max-params, max-depth, max-statements, max-lines-per-function */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\nimport wrap from './callback_wrapper.js';\n\n\n// MAIN //\n\n/**\n* Performs a reduction over an input ndarray according to a callback function and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Function} strategy - input ndarray reshape strategy\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} ibuf - workspace for storing iteration indices\n* @param {NonNegativeIntegerArray} ldims - list of loop dimensions\n* @param {NonNegativeIntegerArray} cdims - list of \"core\" dimensions\n* @param {IntegerArray} strides - loop dimension strides for the input ndarray\n* @param {Options} opts - function options\n* @param {boolean} hasOpts - boolean indicating whether to pass an options argument to a reduction function\n* @param {Function} clbk - callback function\n* @param {*} thisArg - callback exection context\n* @returns {void}\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import accessors from '@stdlib/array-base-accessors';\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import zeros from '@stdlib/array-base-zeros';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': accessors( ybuf ).accessors\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     }\n* ];\n*\n* // Define a reshape strategy:\n* function strategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Create a workspace array for storing iteration indices:\n* var ibuf = zeros( xsh.length );\n*\n* // Define the loop and core dimensions:\n* var ldims = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\n* var cdims = [ 10, 11 ];\n*\n* // Resolve the loop dimension strides for the input array:\n* var slx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ];\n*\n* // Perform a reduction:\n* blockedunary10d( maxBy, [ x, y ], strategy, views, ibuf, ldims, cdims, slx, {}, false, clbk, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ 8.0, 16.0, 24.0 ] ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary10d( fcn, arrays, strategy, views, ibuf, ldims, cdims, strides, opts, hasOpts, clbk, thisArg ) {\n\tvar bsize;\n\tvar ybuf;\n\tvar set;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar dv9;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar ov8;\n\tvar ov9;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\tvar f;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( y.shape, strides, y.strides );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache a reference to the output ndarray buffer:\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tset = y.accessors[ 1 ];\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tov8 = zeros( N );\n\tov9 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tdv8 = zeros( N );\n\tdv9 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov9[ k ] = ov[k] + ( j9*sv[k][9] );\n\t\t}\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv9[ k ] = sv[k][9] - ( s8*sv[k][8] );\n\t\t\t\tov8[ k ] = ov9[k] + ( j8*sv[k][8] );\n\t\t\t}\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv8[ k ] = sv[k][8] - ( s7*sv[k][7] );\n\t\t\t\t\tov7[ k ] = ov8[k] + ( j7*sv[k][7] );\n\t\t\t\t}\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv7[ k ] = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv6[ k ] = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv5[ k ] = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the non-reduced ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategy( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf = wrap( x.ref, views[ 0 ], ibuf, ldims, [ j9+i9, j8+i8, j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], cdims, clbk, thisArg );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iv[1], ( hasOpts ) ? fcn( v, opts, f ) : fcn( v, f ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv8 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv9 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Initialize ndarray-like objects for representing zero-dimensional sub-array views of ancillary ndarray arguments.\n*\n* ## Notes\n*\n* -   This function ignores the first two ndarray-like objects, which are assumed to be the input and output ndarray, respectively.\n* -   This function mutates the provided output array.\n*\n* @private\n* @param {ArrayLikeObject<Object>} arrays - list of ndarray-like objects\n* @param {Array<Object>} out - output array\n* @returns {Array<Object>} output array\n*/\nfunction initializeViews( arrays, out ) {\n\tvar v;\n\tvar i;\n\n\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\tv = arrays[ i ];\n\t\tout.push({\n\t\t\t'dtype': v.dtype,\n\t\t\t'data': v.data,\n\t\t\t'shape': [],\n\t\t\t'strides': [ 0 ],\n\t\t\t'offset': v.offset,\n\t\t\t'order': v.order\n\t\t});\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default initializeViews;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isFunction from '@stdlib/assert-is-function';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport reduce from './main.js';\n\n\n// MAIN //\n\n/**\n* Return a function for performing a reduction over a list of specified dimensions in an input ndarray via a one-dimensional strided array reduction function accepting a callback and assigning results to a provided output ndarray.\n*\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @throws {TypeError} first argument must be a function\n* @returns {Function} function for performing a reduction\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Create a function for performing a reduction over subarrays:\n* var max = factory( maxBy );\n* // returns <Function>\n*\n* // Perform a reduction:\n* max( [ x, y ], [ 2, 3 ], clbk );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 8.0, 16.0, 24.0 ] ]\n*/\nfunction factory( fcn ) {\n\tif ( !isFunction( fcn ) ) {\n\t\tthrow new TypeError( format( 'null3c', fcn ) );\n\t}\n\treturn reducer;\n\n\t/**\n\t* Performs a reduction over a list of specified dimensions in an input ndarray via a one-dimensional strided array reduction function according to a callback function and assigns results to a provided output ndarray.\n\t*\n\t* @private\n\t* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n\t* @param {IntegerArray} dims - list of dimensions over which to perform a reduction\n\t* @param {Options} [options] - function options\n\t* @param {Function} clbk - callback function\n\t* @param {thisArg} [thisArg] - callback execution context\n\t* @returns {void}\n\t*/\n\tfunction reducer( arrays, dims, options, clbk, thisArg ) {\n\t\tvar nargs = arguments.length;\n\t\tif ( nargs < 4 ) {\n\t\t\treturn reduce( fcn, arrays, dims, options );\n\t\t}\n\t\tif ( nargs === 4 ) {\n\t\t\treturn reduce( fcn, arrays, dims, options, clbk );\n\t\t}\n\t\treturn reduce( fcn, arrays, dims, options, clbk, thisArg );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default factory;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Perform a reduction over a list of specified dimensions in an input ndarray via a one-dimensional strided array reduction function accepting a callback and assign results to a provided output ndarray.\n*\n* @module @stdlib/ndarray-base-unary-reduce-strided1d-by\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n* import unaryReduceStrided1dBy from '@stdlib/ndarray-base-unary-reduce-strided1d-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Perform a reduction:\n* unaryReduceStrided1dBy( wrapper, [ x, y ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 10.0, 26.0, 42.0 ] ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import maxBy from '@stdlib/stats-base-ndarray-max-by';\n* import unaryReduceStrided1dBy from '@stdlib/ndarray-base-unary-reduce-strided1d-by';\n*\n* function clbk( value ) {\n*     return value * 2.0;\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 3, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Create a function for performing a reduction over subarrays:\n* var max = unaryReduceStrided1dBy.factory( maxBy );\n* // returns <Function>\n*\n* // Perform a reduction:\n* max( [ x, y ], [ 2, 3 ], clbk );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ 10.0, 26.0, 42.0 ] ]\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport main from './main.js';\nimport factory from './factory.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'factory', factory );\n\n\n// EXPORTS //\n\nexport default main;\n\n// exports: { \"factory\": \"main.factory\" }\n"],"names":["identity","x","broadcast","dtype","data","shape","strides","offset","order","strategy","ndims","xmmv","len","iox","sh","ns","i","length","arr","index","sx","squeeze","iterationOrder","minmaxViewBufferIndex","ind","contiguous","workspace","view","assign","copy","ndarraylike2object","emptyLike","ndarraylike2ndarray","incrementOffsets","offsets","inc","setViewOffsets","views","j","arrays","out","push","MODE","wrap","idx","ldims","lidx","cdims","clbk","thisArg","cidx","zeros","put","v","aidx","ind2sub","call","slice","UNARY","fcn","ibuf","opts","hasOpts","y","f","ref","without","ybuf","dv0","S0","iv","i0","copyIndexed","isRowMajor","dv1","S1","sv","i1","dv2","S2","i2","dv3","S3","i3","dv4","S4","i4","dv5","S5","i5","dv6","S6","i6","dv7","S7","i7","dv8","S8","i8","dv9","S9","i9","ACCESSOR_UNARY","accessors","set","BLOCKED_UNARY","bsize","ov1","s0","s1","ov","j0","j1","N","o","k","loopOrder","sy","takeIndexed","blockSize","ov2","s2","j2","ov3","s3","j3","ov4","s4","j4","ov5","s5","j5","ov6","s6","j6","ov7","s7","j7","ov8","s8","j8","ov9","s9","j9","BLOCKED_ACCESSOR_UNARY","MAX_DIMS","unaryReduceStrided1dBy","dims","options","nargs","tmp","shx","shc","shl","ioy","ord","FLG","ctx","sc","sl","cb","d","s","M","K","arguments","isFunction","ndarray2object","normalizeIndices","RangeError","format","join","sort","Error","indicesComplement","takeIndexed2","numel","initializeViews","reshapeStrategy","accessorProtocol","strides2order","sub","io","vind2bind","accessorunarynd","unarynd","factory","TypeError","reduce","setReadOnly","main"],"mappings":"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"}